# Технологическая(проектно-технологическая) практика
### АВТОРЫ <br /> Шорников Даниил <br /> Олифиренко Максим <br /> Антипин Демид

## Схема работы

![Схема](images/scheme.svg)

## Satellite Emulator

Этот проект представляет собой симулятор, который эмулирует публикацию данных со спутников.

### Описание

Проект разработан для:

- Тестирования систем обработки данных со спутников.
- Разработки и отладки алгоритмов обработки спутниковых данных.
- Обучения работе с данными со спутников.

### Функциональность

- Генерация данных: С помощью API https://api.simurg.space/datafiles/map_files проект загружает архивные данные со спутника.
- Обработка данных: Архивы распаковываются и разделяются на временные интервалы.
- Публикация данных: Симулируется публикация данных через демонов, которые могут быть реализованы в соответствии с требованиями проекта.

### Установка

1. Клонирование репозитория:
```bash
git clone https://github.com/PUTENCHIK/satellite-emulator.git
cd satellite-emulator
```

3. Установка зависимостей:
```bash
pip install -r requirements.txt
```

5. Настройка скриптов:
- download_archive.sh: Скрипт для загрузки и распаковки архивов.
- create_interval_folders.sh: Скрипт для создания папок с временными интервалами.
- run_daemons.sh: Скрипт для запуска демонов (необходимо реализовать).

### Запуск

1. Запуск сервера FastAPI:
```bash
python3 app_start.py
```

2. Запуск эмуляции:
- Откройте браузер и перейдите по адресу http://127.0.0.1:8000/start.
- Введите дату в формате YYYY-MM-DD (например, 2023-03-15) в поле date и нажмите "Start".
### APP.py
Этот код представляет собой серверное приложение на базе FastAPI, предназначенное для эмуляции спутниковых данных. Вот краткое описание его функционала:

WebSocket Endpoint: 
Позволяет клиентам подключаться через WebSocket и получать логи в реальном времени.
Root Endpoint:
Возвращает HTML-страницу, которая может открывать WebSocket соединения и отображать данные.
Date and Stations Endpoints: 
Позволяют получать и устанавливать дату начала эмуляции и список станций.
Active Services Endpoint: 
Проверяет активные системные сервисы, связанные со станциями.
Emulation Control Endpoints: 
Включают в себя /start, /stop, /restart, /update_date для управления процессом эмуляции.
Utility Functions:
Включают функции для загрузки данных, распаковки архивов, проверки станций и обновления даты.
### Main.py
Этот скрипт Python предназначен для загрузки и подготовки спутниковых данных для эмулятора. Вот краткое описание его функционала:

get_data(date: str): 
Асинхронная функция, которая проверяет корректность даты и загружает архив с данными для указанной даты. Если архив уже скачан, функция проверяет его размер и, при необходимости, удаляет и перезагружает его.
unzip(date: str): 
Функция вызывает внешний скрипт для распаковки архива с данными.
### Logger.py
Этот код представляет собой класс Logger, который настраивает логирование в Python. Вот краткое описание его функционала:

Форматирование: 
Определяет формат сообщений лога, включая время, имя, уровень логирования и само сообщение.
Файл лога: 
Логи записываются в файл logs.log, который находится в двух уровнях выше относительно файла скрипта.
Ротация файлов: 
Использует RotatingFileHandler для автоматической ротации логов, ограничивая размер файла до 10 МБ и сохраняя до 5 резервных копий.
Уровень логирования: 
Устанавливает глобальный уровень логирования как DEBUG.
Обработчики: 
Добавляет обработчик файла и, при необходимости, обработчик консоли для вывода логов.
Методы добавления сообщений: 
Предоставляет методы add_debug, add_info, add_warning, add_error для добавления сообщений соответствующего уровня.
Класс Logger может быть использован для удобного логирования различных событий в приложении, обеспечивая централизованное управление логами и их форматированием. Он также поддерживает ротацию логов, что помогает избежать переполнения дискового пространства из-за больших лог-файлов.
#### Использование
Для использования класса `Logger` необходимо создать экземпляр класса с указанием имени логгера и, при необходимости, включить вывод логов в консоль.
```python
from models import Logger

# Создание экземпляра логгера
my_logger = Logger(name="MyAppLogger", console_out=True)

# Добавление сообщений разного уровня
my_logger.add_debug("Это сообщение уровня DEBUG")
my_logger.add_info("Это информационное сообщение")
my_logger.add_warning("Это предупреждение")
my_logger.add_error("Это сообщение об ошибке")
```
